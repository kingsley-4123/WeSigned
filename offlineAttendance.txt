# Offline Attendance via Hotspot — Complete Code Pack

This is a full offline module the **lecturer runs locally** while their **Wi‑Fi hotspot** is on. Students join the hotspot and visit the local URL (or scan a QR). Lecturer can view live attendance and export to **Excel** or **PDF**. After a successful export, the **SQLite data is cleared** and the **session is ended**.

It also explains how to keep your **online** server as a separate deployment using the **same endpoints**.

---

## Project structure

```
offline-attendance/
├─ package.json
├─ server.js                # Express app (offline mode)
├─ db.js                    # SQLite setup & helpers
├─ export-utils.js          # Excel/PDF generators
├─ .env                     # optional (PORT, APP_NAME)
├─ data/                    # SQLite files
├─ public/
│  ├─ index.html            # Role chooser (Student/Lecturer)
│  ├─ lecturer.html         # Lecturer dashboard (start session, table, export)
│  ├─ student.html          # Student sign page
│  ├─ common.js             # IndexedDB specialId, helpers
│  └─ styles.css            # minimal styling
└─ exports/                 # where files are saved (fallback if Documents not available)
```

---

## 1) Install & run

1. **Initialize**

   ```bash
   mkdir offline-attendance && cd offline-attendance
   npm init -y
   npm i express better-sqlite3 exceljs pdfkit qrcode dotenv
   ```
2. Create the files below (copy each block into the named file).
3. **Run**

   ```bash
   node server.js
   ```
4. **Turn on the lecturer’s hotspot**. The server prints LAN URLs like `http://192.168.43.1:3000` — share that with students or show the QR in the dashboard.

> If OS prompts for firewall permission, allow Node to accept incoming connections on the chosen port (default **3000**).

---

## 2) `db.js`

```js
// db.js
const fs = require('fs');
const path = require('path');
const Database = require('better-sqlite3');

const DATA_DIR = path.join(__dirname, 'data');
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

const dbPath = path.join(DATA_DIR, 'offline.db');
const db = new Database(dbPath);

db.pragma('journal_mode = WAL');

db.exec(`
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  name TEXT,
  started_at TEXT NOT NULL,
  ended_at TEXT
);

CREATE TABLE IF NOT EXISTS attendance (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL,
  student_id TEXT NOT NULL,
  special_id TEXT NOT NULL,
  user_agent TEXT,
  ip_address TEXT,
  signed_at TEXT NOT NULL,
  UNIQUE(session_id, student_id),
  UNIQUE(session_id, special_id)
);

CREATE INDEX IF NOT EXISTS idx_attendance_session ON attendance(session_id);
`);

module.exports = {
  db,
  createSession({ id, name, startedAt }) {
    // end any active session
    db.prepare(`UPDATE sessions SET ended_at = ? WHERE ended_at IS NULL`).run(new Date().toISOString());
    db.prepare(`INSERT INTO sessions (id, name, started_at) VALUES (?, ?, ?)`)
      .run(id, name, startedAt);
  },
  getActiveSession() {
    return db.prepare(`SELECT * FROM sessions WHERE ended_at IS NULL ORDER BY started_at DESC LIMIT 1`).get();
  },
  endActiveSession() {
    db.prepare(`UPDATE sessions SET ended_at = ? WHERE ended_at IS NULL`).run(new Date().toISOString());
  },
  addAttendance({ sessionId, studentId, specialId, userAgent, ip, signedAt }) {
    return db.prepare(`INSERT INTO attendance (session_id, student_id, special_id, user_agent, ip_address, signed_at)
      VALUES (?, ?, ?, ?, ?, ?)`)
      .run(sessionId, studentId, specialId, userAgent, ip, signedAt);
  },
  listAttendance(sessionId) {
    return db.prepare(`SELECT id, student_id AS studentId, special_id AS specialId, user_agent AS userAgent, ip_address AS ipAddress, signed_at AS signedAt
      FROM attendance WHERE session_id = ? ORDER BY signed_at DESC`).all(sessionId);
  },
  clearAttendance(sessionId) {
    db.prepare(`DELETE FROM attendance WHERE session_id = ?`).run(sessionId);
  }
};
```

---

## 3) `export-utils.js`

```js
// export-utils.js
const fs = require('fs');
const path = require('path');
const os = require('os');
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function getDocumentsDir() {
  const home = os.homedir();
  const candidates = [
    path.join(home, 'Documents'),
    path.join(home, 'My Documents'),
    path.join(home, 'Documenti'),
    path.join(home, 'Dokumente'),
  ];
  for (const c of candidates) if (fs.existsSync(c)) return c;
  const fallback = path.join(process.cwd(), 'exports');
  ensureDir(fallback);
  return fallback;
}

function timestamp() {
  const d = new Date();
  const pad = (n) => String(n).padStart(2, '0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
}

async function exportExcel({ session, rows }) {
  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet('Attendance');

  sheet.columns = [
    { header: 'Student ID', key: 'studentId', width: 24 },
    { header: 'Special ID', key: 'specialId', width: 40 },
    { header: 'Signed At', key: 'signedAt', width: 24 },
    { header: 'User Agent', key: 'userAgent', width: 50 },
    { header: 'IP Address', key: 'ipAddress', width: 18 },
  ];
  sheet.addRows(rows);

  const dir = getDocumentsDir();
  const fname = `Attendance_${(session.name||'Session').replace(/\s+/g,'_')}_${timestamp()}.xlsx`;
  const full = path.join(dir, fname);
  await workbook.xlsx.writeFile(full);
  return { dir, full, fname };
}

function exportPDF({ session, rows }) {
  const dir = getDocumentsDir();
  const fname = `Attendance_${(session.name||'Session').replace(/\s+/g,'_')}_${timestamp()}.pdf`;
  const full = path.join(dir, fname);

  const doc = new PDFDocument({ size: 'A4', margin: 36 });
  const stream = fs.createWriteStream(full);
  doc.pipe(stream);

  doc.fontSize(16).text(`Attendance — ${session.name || session.id}`, { underline: true });
  doc.moveDown();
  doc.fontSize(10);

  // Table header
  doc.text('Student ID', { continued: true, width: 120 });
  doc.text('Special ID', { continued: true, width: 180 });
  doc.text('Signed At', { continued: true, width: 130 });
  doc.text('IP');
  doc.moveDown(0.5);

  rows.forEach(r => {
    doc.text(r.studentId, { continued: true, width: 120 });
    doc.text(r.specialId, { continued: true, width: 180 });
    doc.text(r.signedAt, { continued: true, width: 130 });
    doc.text(r.ipAddress || '');
  });

  doc.end();

  return new Promise((resolve, reject) => {
    stream.on('finish', () => resolve({ dir, full, fname }));
    stream.on('error', reject);
  });
}

module.exports = { exportExcel, exportPDF };
```

---

## 4) `server.js`

```js
// server.js
require('dotenv').config();
const express = require('express');
const path = require('path');
const os = require('os');
const { randomUUID } = require('crypto');
const QRCode = require('qrcode');
const { db, createSession, getActiveSession, endActiveSession, addAttendance, listAttendance, clearAttendance } = require('./db');
const { exportExcel, exportPDF } = require('./export-utils');

const app = express();
const PORT = process.env.PORT || 3000;
const APP_NAME = process.env.APP_NAME || 'Offline Attendance';

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));

function getLANAddresses() {
  const nets = os.networkInterfaces();
  const addrs = [];
  for (const name of Object.keys(nets)) {
    for (const net of nets[name] || []) {
      if (net.family === 'IPv4' && !net.internal) addrs.push(net.address);
    }
  }
  return addrs;
}

function baseURLs() {
  return getLANAddresses().map(ip => `http://${ip}:${PORT}`);
}

// ---- Session routes ----
app.post('/api/session/start', (req, res) => {
  const name = (req.body.name || '').trim() || `Session ${new Date().toLocaleString()}`;
  const id = randomUUID();
  createSession({ id, name, startedAt: new Date().toISOString() });
  res.json({ id, name, startedAt: new Date().toISOString() });
});

app.get('/api/session/current', (req, res) => {
  const s = getActiveSession();
  if (!s) return res.status(404).json({ message: 'No active session' });
  res.json(s);
});

app.post('/api/session/end', (req, res) => {
  endActiveSession();
  res.json({ ok: true });
});

app.get('/api/session/qr', async (req, res) => {
  const s = getActiveSession();
  if (!s) return res.status(404).json({ message: 'No active session' });
  const joinBase = baseURLs()[0] || `http://localhost:${PORT}`;
  const joinUrl = `${joinBase}/student.html?session=${encodeURIComponent(s.id)}`;
  const dataUrl = await QRCode.toDataURL(joinUrl);
  res.json({ dataUrl, joinUrl });
});

// ---- Attendance routes ----
app.post('/api/attendance/sign', (req, res) => {
  const { sessionId, studentId, specialId } = req.body || {};
  if (!sessionId || !studentId || !specialId) {
    return res.status(400).json({ message: 'sessionId, studentId, specialId are required' });
  }
  const s = getActiveSession();
  if (!s || s.id !== sessionId) {
    return res.status(400).json({ message: 'Session is not active' });
  }
  try {
    addAttendance({
      sessionId,
      studentId: String(studentId).trim(),
      specialId: String(specialId).trim(),
      userAgent: req.headers['user-agent'] || '',
      ip: req.ip,
      signedAt: new Date().toISOString(),
    });
    return res.json({ ok: true, message: 'Attendance signed' });
  } catch (e) {
    if (String(e.message).includes('UNIQUE')) {
      return res.status(409).json({ ok: false, message: 'Already signed in this session (duplicate student or specialId)' });
    }
    console.error(e);
    return res.status(500).json({ ok: false, message: 'Could not sign attendance' });
  }
});

app.get('/api/attendance', (req, res) => {
  const sessionId = req.query.sessionId;
  if (!sessionId) return res.status(400).json({ message: 'sessionId required' });
  const rows = listAttendance(sessionId);
  res.json(rows);
});

// ---- Export routes (stream file, then clear DB and end session) ----
app.post('/api/export/excel', async (req, res) => {
  const session = getActiveSession();
  const sessionId = req.query.sessionId || (session && session.id);
  if (!sessionId) return res.status(400).json({ message: 'sessionId required' });
  const rows = listAttendance(sessionId);
  if (!rows.length) return res.status(400).json({ message: 'No data to export' });
  const s = session && session.id === sessionId ? session : db.prepare('SELECT * FROM sessions WHERE id = ?').get(sessionId);
  try {
    const { full, fname } = await exportExcel({ session: s, rows });
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${fname}"`);
    const stream = require('fs').createReadStream(full);
    stream.pipe(res);
    stream.on('close', () => {
      clearAttendance(sessionId);
      if (getActiveSession() && getActiveSession().id === sessionId) endActiveSession();
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Export failed' });
  }
});

app.post('/api/export/pdf', async (req, res) => {
  const session = getActiveSession();
  const sessionId = req.query.sessionId || (session && session.id);
  if (!sessionId) return res.status(400).json({ message: 'sessionId required' });
  const rows = listAttendance(sessionId);
  if (!rows.length) return res.status(400).json({ message: 'No data to export' });
  const s = session && session.id === sessionId ? session : db.prepare('SELECT * FROM sessions WHERE id = ?').get(sessionId);
  try {
    const { full, fname } = await exportPDF({ session: s, rows });
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${fname}"`);
    const stream = require('fs').createReadStream(full);
    stream.pipe(res);
    stream.on('close', () => {
      clearAttendance(sessionId);
      if (getActiveSession() && getActiveSession().id === sessionId) endActiveSession();
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Export failed' });
  }
});

// ---- Utility ----
app.get('/api/addresses', (req, res) => {
  res.json({ app: APP_NAME, port: PORT, addresses: getLANAddresses(), baseURLs: baseURLs() });
});

app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, '0.0.0.0', () => {
  console.log(`\n${APP_NAME} running on:`);
  baseURLs().forEach(u => console.log('  →', u));
  console.log('Locally:  → http://localhost:' + PORT);
  console.log('\nOpen /lecturer.html to start a session, or /student.html if you already have the QR link.');
});
```

---

## 5) `public/common.js` (IndexedDB specialId with 24‑hour expiry)

```html
<!-- public/common.js -->
<script>
(function(){
  // Minimal IndexedDB key-value store
  const DB_NAME = 'offline-attendance';
  const STORE = 'kv';

  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, { keyPath: 'key' });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  function idbGet(key) {
    return openDB().then(db => new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, 'readonly');
      const st = tx.objectStore(STORE);
      const g = st.get(key);
      g.onsuccess = () => resolve(g.result ? g.result.value : undefined);
      g.onerror = () => reject(g.error);
    }));
  }

  function idbSet(key, value) {
    return openDB().then(db => new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, 'readwrite');
      const st = tx.objectStore(STORE);
      const p = st.put({ key, value });
      p.onsuccess = () => resolve();
      p.onerror = () => reject(p.error);
    }));
  }

  async function getOrCreateSpecialId() {
    const KEY = 'specialId';
    const now = Date.now();
    const rec = await idbGet(KEY);
    if (rec && rec.expiresAt && rec.expiresAt > now && rec.id) {
      return rec.id;
    }
    const id = (self.crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random()).slice(2) + Date.now();
    const expiresAt = now + 24*60*60*1000; // 24h
    await idbSet(KEY, { id, expiresAt });
    return id;
  }

  // Expose to pages
  window.SpecialId = { getOrCreateSpecialId };
})();
</script>
```

---

## 6) `public/index.html`

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Offline Attendance</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <h1>Offline Attendance</h1>
    <p>Select your role:</p>
    <div class="row">
      <a class="btn" href="/lecturer.html">Lecturer</a>
      <a class="btn" href="/student.html">Student</a>
    </div>
  </div>
</body>
</html>
```

---

## 7) `public/lecturer.html`

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lecturer — Offline Attendance</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <h1>Lecturer</h1>

    <section id="start">
      <h2>Start Session</h2>
      <input id="sessionName" placeholder="e.g. CSC 201 — Week 3" />
      <button id="startBtn" class="btn">Start</button>
    </section>

    <section id="current" style="display:none">
      <h2>Current Session</h2>
      <div id="sessionInfo"></div>
      <div class="qr-wrap">
        <img id="qr" alt="QR" />
        <div>
          <p><strong>Student URL:</strong></p>
          <a id="joinUrl" target="_blank"></a>
        </div>
      </div>
      <div class="row">
        <button id="exportExcel" class="btn">Export Excel & Clear</button>
        <button id="exportPdf" class="btn">Export PDF & Clear</button>
        <button id="endBtn" class="btn outline">End Session (no export)</button>
      </div>
    </section>

    <section>
      <h2>Attendance</h2>
      <table id="tbl">
        <thead><tr><th>#</th><th>Student ID</th><th>Special ID</th><th>Signed At</th><th>IP</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <script>
    let currentSession = null;

    async function fetchJSON(url, opts={}) {
      const res = await fetch(url, { headers: { 'Content-Type': 'application/json' }, ...opts });
      if (!res.ok) throw new Error(await res.text());
      return res.json();
    }

    async function loadSession() {
      try {
        currentSession = await fetchJSON('/api/session/current');
        document.getElementById('current').style.display = '';
        document.getElementById('start').style.display = 'none';
        document.getElementById('sessionInfo').textContent = `${currentSession.name} — started ${new Date(currentSession.started_at).toLocaleString()}`;
        const qr = await fetchJSON('/api/session/qr');
        document.getElementById('qr').src = qr.dataUrl;
        const a = document.getElementById('joinUrl');
        a.href = qr.joinUrl; a.textContent = qr.joinUrl;
        pollTable();
      } catch {}
    }

    async function startSession() {
      const name = document.getElementById('sessionName').value.trim();
      await fetchJSON('/api/session/start', { method: 'POST', body: JSON.stringify({ name }) });
      await loadSession();
    }

    async function endSession() {
      await fetchJSON('/api/session/end', { method: 'POST' });
      location.reload();
    }

    async function pollTable() {
      if (!currentSession) return;
      const tbody = document.querySelector('#tbl tbody');
      try {
        const rows = await fetchJSON(`/api/attendance?sessionId=${encodeURIComponent(currentSession.id)}`);
        tbody.innerHTML = rows.map((r, i) => `
          <tr>
            <td>${i+1}</td>
            <td>${r.studentId}</td>
            <td class="mono">${r.specialId}</td>
            <td>${new Date(r.signedAt).toLocaleString()}</td>
            <td>${r.ipAddress||''}</td>
          </tr>`).join('');
      } catch {}
      setTimeout(pollTable, 2000);
    }

    function download(url, method='POST') {
      const form = document.createElement('form');
      form.method = method; form.action = url; form.style.display = 'none';
      document.body.appendChild(form); form.submit();
      setTimeout(() => location.reload(), 2000); // after export, DB clears and session ends
    }

    document.getElementById('startBtn').onclick = startSession;
    document.getElementById('endBtn').onclick = endSession;

    // these need currentSession, so set after loadSession succeeds
    (function bindExport(){
      const wait = setInterval(() => {
        if (!currentSession) return;
        clearInterval(wait);
        document.getElementById('exportExcel').onclick = () => download(`/api/export/excel?sessionId=${encodeURIComponent(currentSession.id)}`);
        document.getElementById('exportPdf').onclick = () => download(`/api/export/pdf?sessionId=${encodeURIComponent(currentSession.id)}`);
      }, 200);
    })();

    loadSession();
  </script>
</body>
</html>
```

---

## 8) `public/student.html`

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Student — Offline Attendance</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <h1>Student Sign‑In</h1>
    <p id="sessionInfo"></p>
    <form id="f">
      <label>Student ID</label>
      <input id="studentId" placeholder="Enter your matric/ID" required />
      <button class="btn" type="submit">Sign Attendance</button>
    </form>
    <p id="msg"></p>
  </div>

  <!-- IndexedDB specialId helper -->
  <script src="/common.js"></script>
  <script>
    const params = new URLSearchParams(location.search);
    const sessionId = params.get('session');
    const $ = (sel) => document.querySelector(sel);

    if (!sessionId) {
      $('#sessionInfo').textContent = 'No session ID in URL. Ask lecturer for the QR/URL.';
      $('#f').style.display = 'none';
    } else {
      $('#sessionInfo').textContent = 'Session ID: ' + sessionId;
    }

    async function sign(e){
      e.preventDefault();
      const studentId = $('#studentId').value.trim();
      if (!studentId) return;
      const specialId = await window.SpecialId.getOrCreateSpecialId();
      try {
        const res = await fetch('/api/attendance/sign', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId, studentId, specialId })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || 'Failed');
        $('#msg').textContent = '✔ Attendance signed.';
        $('#f').reset();
      } catch (err) {
        $('#msg').textContent = '✖ ' + (err.message || 'Could not sign');
      }
    }

    document.getElementById('f').addEventListener('submit', sign);
  </script>
</body>
</html>
```

---

## 9) `public/styles.css`

```css
:root { --fg:#111; --bg:#fafafa; --brand:#2563eb; }
*{ box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
body{ margin:0; background:var(--bg); color:var(--fg); }
.container{ max-width:900px; margin:40px auto; padding:0 16px; }
h1{ margin:0 0 12px; }
section{ margin:18px 0 28px; }
input{ padding:10px 12px; border:1px solid #ddd; border-radius:8px; width:100%; max-width:440px; }
label{ display:block; margin:8px 0 6px; font-weight:600; }
.btn{ display:inline-block; background:var(--brand); color:#fff; padding:10px 14px; border-radius:10px; border:none; cursor:pointer; text-decoration:none; }
.btn:hover{ filter:brightness(0.95); }
.btn.outline{ background:#fff; color:var(--brand); border:1px solid var(--brand); }
.row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
.qr-wrap{ display:flex; gap:16px; align-items:center; }
.qr-wrap img{ width:160px; height:160px; border:1px solid #eee; border-radius:12px; }
.mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }

table{ border-collapse:collapse; width:100%; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 6px rgba(0,0,0,.06); }
th, td{ border-bottom:1px solid #eee; padding:10px 12px; text-align:left; }
th{ background:#f3f4f6; font-weight:700; }
tr:last-child td{ border-bottom:none; }
```

---

## 10) Online mode (same endpoints, different deployment)

You **do not** need two `app.listen()` calls. Run **one instance per environment**:

* **Offline server (lecturer machine)** → this code (SQLite, offline only).
* **Online server (cloud)** → deploy a variant that uses your **cloud DB** (Mongo/Postgres) and (optionally) WebAuthn. Keep the same REST shapes so your front‑end can switch base URLs.

**Pattern:**

```js
// config.js
module.exports = {
  mode: process.env.MODE || 'offline', // 'offline' | 'online'
  port: process.env.PORT || 3000,
};
```

```js
// In your data layer choose DB by mode
const { mode } = require('./config');
if (mode === 'offline') {
  // use SQLite helpers from db.js
} else {
  // use your existing online DB models with the same function names
}
```

Switch at start time:

```bash
# Offline
MODE=offline node server.js
# Online
MODE=online node server.js
```

---

## 11) How the lecturer runs the offline class

1. **Turn on hotspot** on the laptop/phone.
2. **Start the server**: `node server.js`. It prints local URLs (e.g., `http://192.168.43.1:3000`).
3. Visit `http://localhost:3000/lecturer.html` and click **Start Session**.
4. Show students the **QR** or **Student URL** displayed.
5. Students open the link, enter **Student ID**, and tap **Sign** (their `specialId` comes from IndexedDB and lasts **24h**).
6. Watch the **table** update live.
7. Click **Export Excel** or **Export PDF** → file is saved to **Documents** (or `/exports` fallback), the **attendance table is cleared**, and the **session is ended**.

---

## 12) Testing checklist

* Two students try the **same Student ID** in one session → second is **rejected**.
* One student signs **twice** → rejected (unique `(session, student)`).
* Reusing the **same specialId** in a session → rejected (unique `(session, specialId)`).
* After exporting, refresh Lecturer table → should be **empty** and session ended.

---

## 13) Security & hardening tips

* Validate `studentId` format (regex/Joi) before insert.
* Rate‑limit `/api/attendance/sign` to prevent spam (simple in‑memory bucket is fine offline).
* Optionally protect `/lecturer.html` with a PIN in offline mode.
* Consider adding a **short join code** per session that students must type in addition to scanning the QR.
